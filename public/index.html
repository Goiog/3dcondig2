<!DOCTYPE html>
<!-- saved from url=(0044)https://stirring-paletas-6071ca.netlify.app/ -->
<html lang="es">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Damn - Digital Hub</title>
    <link rel="Stylesheet" href="./Global.css" />
    <script src="./Damn - Digital Hub_files/three.min.js"></script>
    <script src="./Damn - Digital Hub_files/GLTFLoader.js"></script>
    <script src="./Damn - Digital Hub_files/OBJLoader.js"></script>
    <script src="./Damn - Digital Hub_files/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5"></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/mdbassit/Coloris@latest/dist/coloris.min.css"
    />
    <script src="https://cdn.jsdelivr.net/gh/mdbassit/Coloris@latest/dist/coloris.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
    <style id="chromane_style">
      body.chromane_rec_nofollow_link_highlighting_enabled a[rel*="nofollow"] {
        margin-right: 8px;
        margin-left: 8px;
        outline: 2px dotted black !important;
        outline-offset: 2px !important;
      }
      body.chromane_rec_sponsored_link_highlighting_enabled
        a[rel*="sponsored"] {
        margin-right: 8px;
        margin-left: 8px;
        outline: 2px dotted black !important;
        outline-color: black;
        outline-offset: 2px !important;
      }
      body.chromane_rec_ugc_link_highlighting_enabled a[rel*="ugc"] {
        margin-right: 8px;
        margin-left: 8px;
        outline: 2px dotted black !important;
        outline-offset: 2px !important;
      }
    </style>
  </head>
  <body class="">
    <div class="container">
      <aside class="sidebar">
        <div class="logo">
          <div class="logo-icon">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
              <path d="M8 5v14l11-7z"></path>
            </svg>
          </div>
          <div>
            <div class="logo-text">Damn</div>
            <div class="logo-subtitle">DIGITAL HUB</div>
          </div>
        </div>

        <div class="search-container">
          <svg
            class="search-icon"
            width="16"
            height="16"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <circle cx="11" cy="11" r="8"></circle>
            <path d="m21 21-4.35-4.35"></path>
          </svg>
          <input type="text" class="search-box" placeholder="Buscar fotos..." />
        </div>

        <nav class="nav-menu">
          <a
            href="https://stirring-paletas-6071ca.netlify.app/#"
            class="nav-item active"
          >
            <svg
              class="icon"
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
              <polyline points="9,22 9,12 15,12 15,22"></polyline>
            </svg>
            <span>Home</span>
          </a>
          <a
            href="https://stirring-paletas-6071ca.netlify.app/#"
            class="nav-item"
          >
            <svg
              class="icon"
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
              <circle cx="9" cy="9" r="2"></circle>
              <path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"></path>
            </svg>
            <span>Gallery</span>
            <span class="badge">71,789</span>
          </a>
          <a
            href="https://stirring-paletas-6071ca.netlify.app/#"
            class="nav-item"
          >
            <svg
              class="icon"
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path
                d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"
              ></path>
            </svg>
            <span>Swipe it</span>
          </a>
          <a
            href="https://stirring-paletas-6071ca.netlify.app/#"
            class="nav-item"
          >
            <svg
              class="icon"
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path
                d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"
              ></path>
            </svg>
            <span>Albums</span>
            <span class="badge">1390</span>
          </a>
          <a
            href="https://stirring-paletas-6071ca.netlify.app/#"
            class="nav-item"
          >
            <svg
              class="icon"
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path
                d="M19 21a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"
              ></path>
            </svg>
            <span>Collections</span>
            <span class="badge">373</span>
          </a>
          <a
            href="https://stirring-paletas-6071ca.netlify.app/#"
            class="nav-item"
          >
            <svg
              class="icon"
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path
                d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"
              ></path>
            </svg>
            <span>Mistery Box</span>
          </a>
          <a
            href="https://stirring-paletas-6071ca.netlify.app/#"
            class="nav-item"
          >
            <svg
              class="icon"
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <circle cx="8" cy="21" r="1"></circle>
              <circle cx="19" cy="21" r="1"></circle>
              <path
                d="M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12"
              ></path>
            </svg>
            <span>Official Market</span>
          </a>

          <div class="nav-section">Biblioteca</div>
          <a
            href="https://stirring-paletas-6071ca.netlify.app/#"
            class="nav-item"
          >
            <svg
              class="icon"
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <polygon
                points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"
              ></polygon>
            </svg>
            <span>Favoritos</span>
            <span class="badge">0</span>
          </a>
          <a
            href="https://stirring-paletas-6071ca.netlify.app/#"
            class="nav-item"
          >
            <svg
              class="icon"
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
              <circle cx="12" cy="10" r="3"></circle>
            </svg>
            <span>Mapa</span>
          </a>
          <a
            href="https://stirring-paletas-6071ca.netlify.app/#"
            class="nav-item"
          >
            <svg
              class="icon"
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path
                d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16z"
              ></path>
            </svg>
            <span>Guardados recientemente</span>
          </a>

          <div class="nav-section">Colecciones</div>
          <a
            href="https://stirring-paletas-6071ca.netlify.app/#"
            class="nav-item"
          >
            <svg
              class="icon"
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
              <line x1="16" y1="2" x2="16" y2="6"></line>
              <line x1="8" y1="2" x2="8" y2="6"></line>
              <line x1="3" y1="10" x2="21" y2="10"></line>
            </svg>
            <span>DÃ­as</span>
          </a>
          <a
            href="https://stirring-paletas-6071ca.netlify.app/#"
            class="nav-item"
          >
            <svg
              class="icon"
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
              <circle cx="12" cy="7" r="4"></circle>
            </svg>
            <span>Personas</span>
          </a>
          <a
            href="https://stirring-paletas-6071ca.netlify.app/#"
            class="nav-item"
          >
            <svg
              class="icon"
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path
                d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"
              ></path>
            </svg>
            <span>Recuerdos</span>
          </a>
        </nav>
      </aside>

      <main class="main-content">
        <header class="header">
          <div class="header-left">
            <button class="back-btn">
              <svg
                width="18"
                height="18"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path d="m15 18-6-6 6-6"></path>
              </svg>
            </button>
            <div class="header-title">
              <h1>Leyenda del club</h1>
              <div class="header-subtitle">Ene 2025 â¢ Campo de Vallecas</div>
            </div>
          </div>
          <div class="header-actions">
            <button class="action-btn">
              <svg
                width="18"
                height="18"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M12 1v6m0 6v6m11-7h-6m-6 0H1"></path>
              </svg>
            </button>
            <button class="action-btn">
              <svg
                width="18"
                height="18"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <circle cx="11" cy="11" r="8"></circle>
                <path d="m21 21-4.35-4.35"></path>
              </svg>
            </button>
            <button class="action-btn">
              <svg
                width="18"
                height="18"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path
                  d="m19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"
                ></path>
              </svg>
            </button>
            <button class="action-btn">
              <svg
                width="18"
                height="18"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path>
                <polyline points="16,6 12,2 8,6"></polyline>
                <line x1="12" y1="2" x2="12" y2="15"></line>
              </svg>
            </button>
            <button class="action-btn">
              <svg
                width="18"
                height="18"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path
                  d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"
                ></path>
              </svg>
            </button>
            <button class="action-btn">
              <svg
                width="18"
                height="18"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <circle cx="12" cy="12" r="1"></circle>
                <circle cx="19" cy="12" r="1"></circle>
                <circle cx="5" cy="12" r="1"></circle>
              </svg>
            </button>
          </div>
        </header>

        <div class="photo-container">
          <div class="photo-main">
            <img
              src="./Damn - Digital Hub_files/6878ff3a13feba0daf6b2b24.webp"
              alt="Leyenda del Rayo Vallecano"
              class="historic-photo"
            />
            <button class="photo-nav prev">â¹</button>
            <button class="photo-nav next">âº</button>
            <div class="photo-tags">
              <span class="photo-tag">Isi PalazÃ³n</span>
              <span class="photo-tag">Ãlvaro GarcÃ­a</span>
              <span class="photo-tag">Sergio Camello</span>
              <span class="photo-tag">Rayo Vallecano</span>
            </div>
          </div>
        </div>

        <div class="custom-products">
          <h2 class="custom-title">
            Make it <span class="yours">yours.</span>
          </h2>
          <p class="custom-subtitle">
            Transform your favorite Damn moments into premium products.<br />Crafted
            with precision. Made to last.
          </p>

          <div class="products-section">
            <div class="product-buttons">
              <h3 class="section-title">Choose your product</h3>

              <div class="product-item featured" data-product="Mug">
                <div class="product-info">
                  <h3>Mug</h3>
                  <p>Premium ceramic</p>
                </div>
                <div class="product-price">â¬24.99</div>
              </div>

              <div class="product-item" data-product="Shirt">
                <div class="product-info">
                  <h3>T-Shirt</h3>
                  <p>100% organic cotton</p>
                </div>
                <div class="product-price">â¬29.99</div>
              </div>

              <div class="product-item" data-product="Cap">
                <div class="product-info">
                  <h3>Cap</h3>
                  <p>Adjustable fit</p>
                </div>
                <div class="product-price">â¬19.99</div>
              </div>

              <div class="product-item" data-product="Poster">
                <div class="product-info">
                  <h3>Poster</h3>
                  <p>Museum quality</p>
                </div>
                <div class="product-price">â¬34.99</div>
              </div>
            </div>

            <div class="preview-section" style="position: relative">
              <h3 class="section-title" style="margin-bottom: 10px">Preview</h3>
              <div class="preview-price" style="margin-bottom: 10px">
                â¬24.99
              </div>
              <div
                id="iframe_div"
                style="
                  width: 100%;
                  height: 579px;
                  z-index: 200;
                  position: relative;
                "
              >
                <iframe
                  id="canvas"
                  src="https://damn-3dproduct-mpb8.vercel.app/?model=Mug"
                  width="100%"
                  height="100%"
                ></iframe>
                <div class="loading-indicator" id="loading-indicator" style="display: none">
                  <div class="loading-spinner"></div>
                  <span id="loading-text">Loading model...</span>
                  <span id="loading-progress" style="margin-top:6px;font-weight:600;display:block;">0%</span>
                </div>
                <div
                  id="loading-indicator-image"
                  style="
                    width: 100%;
                    height: 100%;
                    background-color: #00000093;
                    position: absolute;
                    top: 0;
                    left: 0;
                    border-radius: 20px;
                    display: none;
                  "
                >
                  <div class="loading-indicator" style="display: block">
                    <div class="loading-spinner"></div>
                    <span id="loading-text">AI is removing background...</span>
                  </div>
                </div>
              </div>

              <button class="order-btn">Order now</button>

              <div class="features">
                <div class="feature-item">
                  <div class="feature-dot green"></div>
                  <span>Free shipping</span>
                </div>
                <div class="feature-item">
                  <div class="feature-dot blue"></div>
                  <span>Quality guarantee</span>
                </div>
                <div class="feature-item">
                  <div class="feature-dot purple"></div>
                  <span>Unique customization</span>
                </div>
                <div class="feature-item">
                  <div class="feature-dot orange"></div>
                  <span>5-7 days delivery</span>
                </div>
              </div>
            </div>

            <div class="product-options">
              <h3 class="section-title">Customization</h3>
              <div class="customization-buttons button-wrapper">
                <button class="flex-1 active">Image</button>
                <button class="flex-1">Text</button>
              </div>

              <div class="configurator-controls" style="min-height: 742px">
                <div
                  id="image-customization"
                  style="display: block"
                  data-type="image-customization"
                >
                  <div class="control-group">
                    <label class="control-label">Upload Image</label>
                    <div class="upload-area" id="upload-area">
                      <div class="upload-icon">ð</div>
                      <div class="upload-text">Click to upload image</div>
                      <div class="upload-hint">JPG, PNG, WebP (max 5MB)</div>
                      <input
                        type="file"
                        id="image-upload"
                        accept="image/*"
                        style="display: none"
                      />
                    </div>
                    
                    <div
                      class="control-group"
                      style="width: 100%; margin-top: 12px"
                    >
                      <div
                        style="
                          display: flex;
                          flex-direction: row;
                          justify-content: space-between;
                          align-items: center;
                        "
                      >
                        <label class="control-label" style="margin-top: 6px"
                          >Image Layers</label
                        >
                        <button class="remove-bg-btn control-btn">
                          Remove Bg
                        </button>
                      </div>
                      <div class="image_layers"></div>
                    </div>
                  </div>
                  <div style="margin-top: 12px; position: relative; display: inline-block;padding-bottom: 40px;">
                    <label style="display:block; font-weight:600; margin-bottom:6px;">2D Preview</label>

                    <!-- Canvas / Image -->
                    <img id="mug-2d-preview" alt="2D Mug Design" 
                         style="max-width: 83%; left:20px;border: 1px solid #ddd; border-radius: 8px; position: relative; z-index: 1; cursor: grab;" />

                    <!-- Layout Overlay (your uploaded PNG) -->
                    <img src="Damn - Digital Hub_files/Layout_Mug.png" alt="Mug layout" 
                         style="position: absolute; bottom: -3px; left: 50%; transform: translateX(-50%); z-index: 2; pointer-events: none; max-width: 100%;" />
                  </div>

                  <div class="control-group">
                    <label class="control-label">Image Size</label>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                      <span style="font-size: 12px; color: #666;">Value:</span>
                      <!--<span id="size-value-display" style="font-size: 12px; font-weight: 600; color: #333;">920</span> -->
                    </div>
                    <input
                      type="range"
                      class="control-slider"
                      id="size-slider"
                      min="10"
                      max="2000"
                      step="10"
                      value="920"
                    />
                    <div
                      style="
                        display: flex;
                        justify-content: space-between;
                        font-size: 12px;
                        color: #666;
                      "
                    >
                      <span>Small</span>
                      <span>Large</span>
                    </div>
                  </div>
                  <!--
                  <div
                    class="control-group poster-specific"
                    style="display: none"
                  >
                    <label class="control-label">Poster Frame Style</label>
                    <div class="control-buttons">
                      <button
                        class="control-btn frame-btn active"
                        data-frame="wood"
                      >
                        Wood
                      </button>
                      <button class="control-btn frame-btn" data-frame="metal">
                        Metal
                      </button>
                      <button
                        class="control-btn frame-btn"
                        data-frame="minimal"
                      >
                        Minimal
                      </button>
                    </div>
                  </div>

                  <div class="control-group">
                    <label class="control-label">Image Position</label>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                      <span style="font-size: 12px; color: #666;">X:</span>
                      <span id="x-position-value-display" style="font-size: 12px; font-weight: 600; color: #333;">0</span>
                      <span style="font-size: 12px; color: #666;">Y:</span>
                      <span id="y-position-value-display" style="font-size: 12px; font-weight: 600; color: #333;">0</span>
                    </div>
                    <div
                      style="
                        display: grid;
                        grid-template-columns: 1fr 1fr;
                        gap: 8px;
                      "
                    >
                      <input
                        type="range"
                        class="control-slider"
                        id="x-position"
                        min="-800"
                        max="806"
                        step="0.1"
                        value="0"
                      />
                      <input
                        type="range"
                        class="control-slider"
                        id="y-position"
                        min="-800"
                        max="823"
                        step="0.1"
                        value="0"
                      />
                    </div>
                    <div
                      style="
                        display: flex;
                        justify-content: space-between;
                        font-size: 12px;
                        color: #666;
                      "
                    >
                      <span>Left/Right</span>
                      <span>Up/Down</span>
                    </div>
                  </div>

                  <div class="control-group">
                    <label class="control-label">Image Rotation</label>
                    <input
                      type="range"
                      class="control-slider"
                      id="rotation-slider"
                      min="0"
                      max="720"
                      step="1"
                      value="0"
                    />
                    <div
                      style="
                        display: flex;
                        justify-content: space-between;
                        font-size: 12px;
                        color: #666;
                      "
                    >
                      <span>0Â°</span>
                      <span>360Â°</span>
                    </div>
                  </div>
                </div>-->
                <div
                  id="text-customization"
                  style="display: none"
                  data-type="text-customization"
                >
                  <div class="control-group">
                    <label class="control-label">Add Text</label>
                    <textarea
                      id="add_text_inp"
                      type="text"
                      class=""
                      style="
                        width: 100%;
                        min-height: 35px;
                        border-radius: 10px;
                        outline: none;
                        border: 1px solid gray;
                        padding-inline: 10px;
                        resize: none;
                        field-sizing: content;
                        padding-block: 9px;
                      "
                    ></textarea>
                    <button
                      id="add_text"
                      class="active"
                      style="
                        width: 100%;
                        margin-top: 5px;
                        height: 35px;
                        background: black;
                        color: white;
                        border-radius: 10px;
                        font-size: 14px;
                        font-weight: 500;
                        cursor: pointer;
                      "
                    >
                      Add Text
                    </button>
                  </div>
                  <div class="control-group" style="width: 100%">
                    <label class="control-label">Text Layers</label>
                    <div class="text_layers"></div>
                  </div>

                  <div class="control-group" style="width: 100%">
                    <label class="control-label">Text Color</label>
                    <input
                      type="text"
                      data-coloris
                      style="
                        width: 85%;
                        height: 25px;
                        border-radius: 6px;
                        border: #80808087 solid 1px;
                        padding-inline: 10px;
                      "
                    />
                  </div>
                  <div class="control-group" style="width: 100%">
                    <label class="control-label">Fonts</label>
                    <div
                      class="font-inp"
                      style="
                        width: 100%;
                        height: 30px;
                        border-radius: 10px;
                        padding-inline: 10px;
                        cursor: pointer;
                      "
                    >
                      <div
                        style="width: 100%; height: 100%; place-content: center"
                      >
                        <span class="selected-font">System UI</span>
                      </div>
                      <div class="custom-dialog">
                        <ul></ul>
                      </div>
                    </div>
                  </div>
                  <div class="control-group">
                    <label class="control-label">Text Size</label>
                    <input
                      type="range"
                      class="control-slider"
                      id="size-slider"
                      min="1"
                      max="6"
                      step="0.25"
                      value="2"
                    />
                    <div
                      style="
                        display: flex;
                        justify-content: space-between;
                        font-size: 12px;
                        color: #666;
                      "
                    >
                      <span>Small</span>
                      <span>Large</span>
                    </div>
                  </div>
                  <div class="control-group" style="width: 100%">
                    <label class="control-label" style="margin-bottom: -4px"
                      >Line Height</label
                    >
                    <input
                      type="range"
                      class="control-slider"
                      id="line-height-slider"
                      min="0.1"
                      max="4"
                      step="0.15"
                      value="2"
                    />
                    <div
                      style="
                        display: flex;
                        justify-content: space-between;
                        font-size: 12px;
                        color: #666;
                      "
                    >
                      <span>Small</span>
                      <span>Large</span>
                    </div>
                  </div>

                  <div class="control-group">
                    <label class="control-label">Text Position</label>
                    <div
                      style="
                        display: grid;
                        grid-template-columns: 1fr 1fr;
                        gap: 8px;
                      "
                    >
                      <input
                        type="range"
                        class="control-slider"
                        id="x-position"
                        min="12"
                        max="685"
                        step="5"
                        value="0"
                      />
                      <input
                        type="range"
                        class="control-slider"
                        id="y-position"
                        min="-21"
                        max="744"
                        step="5"
                        value="0"
                      />
                    </div>
                    <div
                      style="
                        display: flex;
                        justify-content: space-between;
                        font-size: 12px;
                        color: #666;
                      "
                    >
                      <span>Left/Right</span>
                      <span>Up/Down</span>
                    </div>
                  </div>

                  <div class="control-group">
                    <label class="control-label">Text Rotation</label>
                    <input
                      type="range"
                      class="control-slider"
                      id="rotation-slider"
                      min="0"
                      max="720"
                      step="1"
                      value="0"
                    />
                    <div
                      style="
                        display: flex;
                        justify-content: space-between;
                        font-size: 12px;
                        color: #666;
                      "
                    >
                      <span>0Â°</span>
                      <span>360Â°</span>
                    </div>
                  </div>
                </div>

                <div class="control-group">
                  <label class="control-label">Product Color</label>
                  <div id="picker" style="position: relative">
                    <div
                      style="
                        position: absolute;
                        top: 0;
                        right: 0;
                        width: 119px;
                        padding-left: 10px;
                      "
                    >
                      <input
                        type="text"
                        value="#ffffff"
                        id="model-color-inp"
                        style="
                          width: 100%;
                          background-color: #ece6e6;
                          border: 1px solid #666;
                          border-radius: 10px;
                          height: 25px;
                          padding-inline: 8px;
                          margin-bottom: 10px;
                        "
                      />
                      <div
                        id="color-dor-parent"
                        style="
                          display: flex;
                          flex-direction: row;
                          flex-wrap: wrap;
                        "
                      >
                        <div data-color="#ff6b6b" class="color-dot red"></div>
                        <div data-color="#6bcb77" class="color-dot green"></div>
                        <div data-color="#4d96ff" class="color-dot blue"></div>
                        <div
                          data-color="#ffd93d"
                          class="color-dot yellow"
                        ></div>
                        <div
                          data-color="#6a4c93"
                          class="color-dot purple"
                        ></div>
                        <div
                          data-color="#ff9f1c"
                          class="color-dot orange"
                        ></div>
                        <div data-color="#00b8a9" class="color-dot teal"></div>
                        <div data-color="#ff5c8a" class="color-dot pink"></div>
                        <div data-color="#a0a0a0" class="color-dot gray"></div>
                        <div data-color="#222222" class="color-dot black"></div>
                        <div
                          data-color="#1abc9c"
                          class="color-dot turquoise"
                        ></div>
                        <div
                          data-color="#3498db"
                          class="color-dot skyblue"
                        ></div>
                        <div
                          data-color="#9b59b6"
                          class="color-dot violet"
                        ></div>
                        <div
                          data-color="#e74c3c"
                          class="color-dot crimson"
                        ></div>
                        <div data-color="#34495e" class="color-dot navy"></div>
                        <div data-color="#f39c12" class="color-dot amber"></div>
                        <div
                          data-color="#27ae60"
                          class="color-dot emerald"
                        ></div>
                        <div data-color="#8e44ad" class="color-dot plum"></div>
                        <div
                          data-color="#2c3e50"
                          class="color-dot charcoal"
                        ></div>
                        <div
                          data-color="#ecf0f1"
                          class="color-dot lightgray"
                        ></div>
                      </div>
                    </div>
                  </div>

                  <div
                    id="texture-notice"
                    style="
                      display: none;
                      font-size: 12px;
                      color: #d32f2f;
                      margin-top: 8px;
                      font-weight: 500;
                    "
                  >
                    â ï¸ Image applied - color changes will affect non-image parts
                    only
                  </div>
                </div>

                <div class="control-group">
                  <label class="control-label">Model Rotation</label>
                  <div class="control-buttons">
                    <button
                      class="control-btn active"
                      id="auto-rotate-btn"
                      style="width: 100%"
                    >
                      Stop Rotate
                    </button>
                    <button
                      class="control-btn"
                      id="reset-view-btn"
                      style="width: 100%"
                    >
                      Reset View
                    </button>
                  </div>
                  <button
                    class="control-btn"
                    id="export-view-btn"
                    style="width: 100%; margin-top: 10px"
                  >
                    Export
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="related-photos">
          <h2 class="related-title">Fotos relacionadas</h2>
          <div class="photo-grid">
            <div class="photo-card">
              <div class="photo-placeholder">Hugo Duro - Goleador</div>
            </div>
            <div class="photo-card">
              <div class="photo-placeholder">Equipo HistÃ³rico</div>
            </div>
            <div class="photo-card">
              <div class="photo-placeholder">CelebraciÃ³n Vallecas</div>
            </div>
            <div class="photo-card">
              <div class="photo-placeholder">AficiÃ³n Rayista</div>
            </div>
            <div class="photo-card">
              <div class="photo-placeholder">ExposiciÃ³n Centenario</div>
            </div>
            <div class="photo-card">
              <div class="photo-placeholder">Gol HistÃ³rico</div>
            </div>
            <div class="photo-card">
              <div class="photo-placeholder">Cantera Rayo</div>
            </div>
            <div class="photo-card">
              <div class="photo-placeholder">Trofeo Primera</div>
            </div>
          </div>
        </div>
      </main>
    </div>

    <script>
      // Global utility functions
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      function throttle(func, limit) {
        let inThrottle;
        return function () {
          const args = arguments;
          const context = this;
          if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
          }
        };
      }

      // Simple logging function
      function log(message, type = "info") {
        console.log(`[${type.toUpperCase()}] ${message}`);
      }

      // Global systems
      let notifications = {
        showing: false,
        show: function (message, type = "info") {
          // Create notification element
          this.showing = true;
          const notification = document.createElement("div");
          notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 12px 20px;
                    border-radius: 8px;
                    color: white;
                    font-weight: 500;
                    z-index: 10000;
                    max-width: 300px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    transform: translateX(100%);
                    transition: transform 0.3s ease;
                `;

          // Set background color based on type
          switch (type) {
            case "success":
              notification.style.background = "#34c759";
              break;
            case "error":
              notification.style.background = "#ff3b30";
              break;
            case "warning":
              notification.style.background = "#ff9500";
              break;
            default:
              notification.style.background = "#007aff";
          }

          notification.textContent = message;
          document.body.appendChild(notification);

          // Animate in
          setTimeout(() => {
            notification.style.transform = "translateX(0)";
          }, 100);

          // Auto remove after 3 seconds
          setTimeout(() => {
            notification.style.transform = "translateX(100%)";
            setTimeout(() => {
              if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
                this.showing = false;
              }
            }, 300);
          }, 3000);
        },
      };

      // Global state variables
      let uploadedImage = null;
      let currentModel = null;
      let targetMaterial = null;
      let currentProduct = "poster";
      let originalMaterials = new Map();
      let posterCanvasMesh = null;
      let posterFrameMesh = null;

      // Simple debug logging
      function debugLog(message, type = "info") {
        console.log(`[${type.toUpperCase()}] ${message}`);
      }

      // Navigation functionality
      document.querySelectorAll(".nav-item").forEach((item) => {
        item.addEventListener("click", (e) => {
          e.preventDefault();
          document
            .querySelectorAll(".nav-item")
            .forEach((nav) => nav.classList.remove("active"));
          item.classList.add("active");

          document.querySelector("#canvas").src = "";
        });
      });

      // Photo navigation
      let currentPhoto = 0;
      const photoDescriptions = [
        "Leyenda histÃ³rica del Rayo",
        "Momento Ã©pico en Vallecas",
        "Gloria rayista eterna",
      ];

      document
        .querySelector(".photo-nav.prev")
        .addEventListener("click", () => {
          currentPhoto =
            (currentPhoto - 1 + photoDescriptions.length) %
            photoDescriptions.length;
          console.log("Mostrando:", photoDescriptions[currentPhoto]);
        });

      document
        .querySelector(".photo-nav.next")
        .addEventListener("click", () => {
          currentPhoto = (currentPhoto + 1) % photoDescriptions.length;
          console.log("Mostrando:", photoDescriptions[currentPhoto]);
        });

      // Initialize 3D Scene
      function init3DScene() {
        // Since we're using an iframe for 3D, we don't need to initialize Three.js here
        // The 3D scene is handled by the external Vercel app
        // This function now just handles the iframe communication setup
        console.log("3D scene communication initialized");
        return;

        // Scene setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf8f9fa);

        // Camera setup
        camera = new THREE.PerspectiveCamera(
          75,
          container.clientWidth / container.clientHeight,
          0.1,
          1000
        );
        camera.position.set(0, 0, 5);

        // Renderer setup
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // Controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 5, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Enhanced animation loop with performance monitoring
        function animate() {
          requestAnimationFrame(animate);
          controls.update();

          // Auto rotate model if enabled
          if (autoRotate && currentModel) {
            currentModel.rotation.y += 0.01;
          }

          renderer.render(scene, camera);
        }
        animate();

        // Load default model
        loadProductModel("poster");
      }

      // Enhanced model loading with better performance and error handling
      function loadProductModel(productType) {
        // Store the current uploaded image before clearing
        const currentUploadedImage = uploadedImage;

        // Dispose of existing model to prevent memory leaks
        if (currentModel) {
          currentModel.traverse((child) => {
            if (child.isMesh) {
              if (child.geometry) child.geometry.dispose();
              if (child.material) {
                if (Array.isArray(child.material)) {
                  child.material.forEach((mat) => {
                    if (mat.map) mat.map.dispose();
                    mat.dispose();
                  });
                } else {
                  if (child.material.map) child.material.map.dispose();
                  child.material.dispose();
                }
              }
            }
          });
          scene.remove(currentModel);
          currentModel = null;
        }

        targetMaterial = null;
        originalMaterials.clear();

        currentProduct = productType;

        // Model URLs with fallback validation
        const modelUrls = {
          mug: "./plain_mug2.glb",
          tshirt: "./tshirt.glb",
          cap: "./cap.glb",
          poster: "./poster.glb",
        };

        if (modelUrls[productType]) {
          console.log(`Loading ${productType}...`);
          loadGLBModel(
            modelUrls[productType],
            productType,
            currentUploadedImage
          );
        } else {
          const errorMsg = `Model for ${productType} not found`;
          debugLog(errorMsg, "error");
          console.error(errorMsg);
        }
      }

      // Load Model (GLB or OBJ)
      function loadGLBModel(url, productType, preserveImage = null) {
        const isOBJ = url.toLowerCase().endsWith(".obj");
        const loader = isOBJ ? new THREE.OBJLoader() : new THREE.GLTFLoader();

        debugLog(
          `Starting to load ${productType} ${isOBJ ? "OBJ" : "GLB"} model...`,
          "loading"
        );

        // Show loading indicator
        const loadingIndicator = document.getElementById("loading-indicator");
        const loadingText = document.getElementById("loading-text");
        loadingText.textContent = `Loading ${productType}...`;
        loadingIndicator.style.display = "flex";

        loader.load(
          url,
          (result) => {
            const model = isOBJ ? result : result.scene;

            // --- 1. Enhanced Camera Framing for Poster ---
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));

            // Special handling for poster - closer view
            if (productType === "poster") {
              cameraZ *= 1.2; // Closer view for poster
              // Position camera slightly above and angled for better poster view
              camera.position.set(
                center.x + 0.5,
                center.y + 0.3,
                center.z + cameraZ
              );
            } else {
              cameraZ *= 1.5; // Standard padding for other products
              camera.position.set(center.x, center.y, center.z + cameraZ);
            }

            controls.target.copy(center);
            controls.update();

            // --- 2. Enhanced Material Processing for Poster ---
            let largestMesh = null;
            let maxArea = 0;
            let allMaterials = [];
            let posterFrame = null;
            let posterCanvas = null;

            model.traverse((child) => {
              if (child.isMesh) {
                const geometry = child.geometry;
                if (geometry) {
                  // Calculate mesh area more accurately
                  const meshSize = new THREE.Box3()
                    .setFromObject(child)
                    .getSize(new THREE.Vector3());
                  const area =
                    meshSize.x * meshSize.y +
                    meshSize.y * meshSize.z +
                    meshSize.z * meshSize.x;

                  // Special handling for poster - look for frame and canvas separately
                  if (productType === "poster") {
                    const meshName = child.name.toLowerCase();
                    debugLog(`Found mesh: ${child.name} (${meshName})`, "info");

                    // More comprehensive frame detection
                    if (
                      meshName.includes("frame") ||
                      meshName.includes("border") ||
                      meshName.includes("wood") ||
                      meshName.includes("edge") ||
                      meshName.includes("trim")
                    ) {
                      posterFrame = child;
                      posterFrameMesh = child;
                      debugLog(`Identified frame: ${child.name}`, "success");
                    } else if (
                      meshName.includes("canvas") ||
                      meshName.includes("surface") ||
                      meshName.includes("paper") ||
                      meshName.includes("image") ||
                      meshName.includes("texture") ||
                      meshName.includes("plane") ||
                      meshName.includes("area")
                    ) {
                      posterCanvas = child;
                      posterCanvasMesh = child;
                      debugLog(`Identified canvas: ${child.name}`, "success");
                      if (area > maxArea) {
                        maxArea = area;
                        largestMesh = child;
                      }
                    } else {
                      // For any other mesh, check if it might be the canvas
                      // Look for meshes that are not the frame and have reasonable area
                      if (
                        !meshName.includes("frame") &&
                        !meshName.includes("border") &&
                        !meshName.includes("wood") &&
                        !meshName.includes("edge") &&
                        !meshName.includes("trim")
                      ) {
                        if (area > maxArea) {
                          maxArea = area;
                          largestMesh = child;
                        }
                      }
                    }

                    // Special handling for OBJ files - if no specific names found, use the largest mesh as canvas
                    if (isOBJ && !posterCanvas && largestMesh) {
                      posterCanvas = largestMesh;
                      posterCanvasMesh = largestMesh;
                      debugLog(
                        `OBJ: Using largest mesh as canvas: ${largestMesh.name}`,
                        "warning"
                      );
                    }
                  } else {
                    // Standard handling for other products
                    if (area > maxArea) {
                      maxArea = area;
                      largestMesh = child;
                    }
                  }

                  // Store all materials for processing
                  if (child.material) {
                    allMaterials.push({
                      mesh: child,
                      material: child.material,
                      area: area,
                      name: child.name,
                    });
                  }
                }
              }
            });

            // Enhanced material processing
            allMaterials.forEach(({ mesh, material, name }) => {
              // Store original material for reset
              originalMaterials.set(mesh, material.clone());

              // Special handling for different product types
              if (productType === "poster") {
                const meshName = name.toLowerCase();
                if (meshName.includes("frame") || meshName.includes("border")) {
                  // Keep frame material as is (wood, metal, etc.)
                  debugLog(`Frame material preserved: ${name}`, "info");
                } else {
                  // Make canvas/surface white for texture application
                  mesh.material = material.clone();
                  mesh.material.color.set(0xffffff);
                  mesh.material.needsUpdate = true;
                }
              } else if (productType === "tshirt") {
                // For t-shirts, ensure all fabric materials are white
                const meshName = name.toLowerCase();
                if (
                  meshName.includes("fabric") ||
                  meshName.includes("cloth") ||
                  meshName.includes("front") ||
                  meshName.includes("back") ||
                  meshName.includes("body")
                ) {
                  mesh.material = material.clone();
                  mesh.material.color.set(0xffffff);
                  mesh.material.needsUpdate = true;
                  debugLog(
                    `T-shirt fabric material set to white: ${name}`,
                    "success"
                  );
                } else {
                  // Keep non-fabric materials (like tags, seams) as they are
                  debugLog(
                    `T-shirt non-fabric material preserved: ${name}`,
                    "info"
                  );
                }
              } else {
                // Standard white base for other products
                mesh.material = material.clone();
                mesh.material.color.set(0xffffff);
                mesh.material.needsUpdate = true;
              }
            });

            // Additional processing for OBJ files - ensure materials are properly initialized
            if (isOBJ && productType === "poster") {
              debugLog("Processing OBJ poster materials...", "info");
              model.traverse((child) => {
                if (child.isMesh) {
                  // Ensure material exists and is properly configured
                  if (!child.material) {
                    child.material = new THREE.MeshStandardMaterial({
                      color: 0xffffff,
                    });
                    debugLog(
                      `Created material for OBJ mesh: ${child.name}`,
                      "info"
                    );
                  } else {
                    // Ensure material properties are set correctly
                    child.material.color.set(0xffffff);
                    child.material.needsUpdate = true;
                    debugLog(
                      `Updated material for OBJ mesh: ${child.name}`,
                      "info"
                    );
                  }
                }
              });
            }

            // Additional processing for material arrays
            model.traverse((child) => {
              if (child.isMesh) {
                if (Array.isArray(child.material)) {
                  child.material = child.material.map((mat, index) => {
                    if (mat) {
                      originalMaterials.set(
                        `${child.name}_${index}`,
                        mat.clone()
                      );
                      if (
                        productType === "poster" &&
                        child.name.toLowerCase().includes("frame")
                      ) {
                        // Preserve frame materials
                        debugLog(
                          `Frame material array preserved: ${child.name}_${index}`,
                          "info"
                        );
                        return mat.clone();
                      } else {
                        const newMat = mat.clone();
                        newMat.color.set(0xffffff);
                        newMat.needsUpdate = true;
                        return newMat;
                      }
                    }
                    return mat;
                  });
                } else if (child.material) {
                  if (
                    !allMaterials.some((m) => m.material === child.material)
                  ) {
                    originalMaterials.set(child, child.material.clone());
                    if (
                      productType === "poster" &&
                      child.name.toLowerCase().includes("frame")
                    ) {
                      // Preserve frame materials
                      debugLog(
                        `Frame material preserved: ${child.name}`,
                        "info"
                      );
                    } else {
                      child.material = child.material.clone();
                      child.material.color.set(0xffffff);
                      child.material.needsUpdate = true;
                    }
                  }
                }
              }
            });

            // Set target material for texture application
            if (productType === "poster") {
              // For posters, prioritize the canvas material
              if (posterCanvas && posterCanvas.material) {
                targetMaterial = posterCanvas.material;
                debugLog(
                  `Poster canvas material identified: ${posterCanvas.name}`,
                  "success"
                );
              } else if (largestMesh && largestMesh.material) {
                targetMaterial = largestMesh.material;
                debugLog(
                  `Using largest mesh material for poster: ${largestMesh.name}`,
                  "warning"
                );
              } else {
                // Fallback: find any material that's not the frame
                const nonFrameMaterial = allMaterials.find(({ name }) => {
                  const meshName = name.toLowerCase();
                  return (
                    !meshName.includes("frame") &&
                    !meshName.includes("border") &&
                    !meshName.includes("wood")
                  );
                });

                if (nonFrameMaterial) {
                  targetMaterial = nonFrameMaterial.material;
                  debugLog(
                    `Using non-frame material for poster: ${nonFrameMaterial.name}`,
                    "warning"
                  );
                } else if (allMaterials.length > 0) {
                  targetMaterial = allMaterials[0].material;
                  debugLog(
                    `Using fallback material for poster: ${allMaterials[0].name}`,
                    "warning"
                  );
                } else {
                  // If no material found, create one for the largest mesh
                  if (largestMesh) {
                    largestMesh.material = new THREE.MeshStandardMaterial({
                      color: 0xffffff,
                    });
                    targetMaterial = largestMesh.material;
                    debugLog(
                      `Created new material for poster canvas: ${largestMesh.name}`,
                      "success"
                    );
                  } else {
                    debugLog(
                      `No suitable material or mesh found for poster`,
                      "error"
                    );
                  }
                }
              }

              // Additional debugging for OBJ files
              if (isOBJ) {
                debugLog(
                  `OBJ Poster - Total materials: ${allMaterials.length}`,
                  "info"
                );
                debugLog(
                  `OBJ Poster - Canvas mesh: ${
                    posterCanvas ? posterCanvas.name : "None"
                  }`,
                  "info"
                );
                debugLog(
                  `OBJ Poster - Frame mesh: ${
                    posterFrame ? posterFrame.name : "None"
                  }`,
                  "info"
                );
                debugLog(
                  `OBJ Poster - Target material: ${
                    targetMaterial ? "Found" : "None"
                  }`,
                  "info"
                );
              }
            } else {
              // Standard handling for other products
              if (largestMesh && largestMesh.material) {
                targetMaterial = largestMesh.material;
                debugLog(
                  `Target material identified for ${productType}: ${largestMesh.name}`,
                  "success"
                );
              } else {
                // Fallback: use the first available material
                if (allMaterials.length > 0) {
                  targetMaterial = allMaterials[0].material;
                  debugLog(
                    `Using fallback material for ${productType}: ${allMaterials[0].name}`,
                    "warning"
                  );
                } else {
                  debugLog(
                    `No suitable material found for ${productType}`,
                    "error"
                  );
                }
              }
            }

            // Debug logging
            debugLog(
              `Total materials processed for ${productType}: ${allMaterials.length}`,
              "info"
            );
            allMaterials.forEach(({ mesh, material, name }, index) => {
              debugLog(
                `Material ${index}: ${name} - Color: ${material.color.getHexString()}`,
                "info"
              );
            });

            // Store available materials for debug functionality
            if (productType === "poster") {
              availableMaterials = allMaterials;
              currentMaterialIndex = 0;
            }

            currentModel = model;
            scene.add(model);

            // Reapply texture if there was a preserved image
            if (preserveImage) {
              uploadedImage = preserveImage;
              applyTexture(preserveImage);

              // Show the image preview again
              const preview = document.getElementById("image-preview");
              preview.src = preserveImage;
              preview.style.display = "block";

              debugLog(`Reapplied texture to ${productType} model.`, "success");
            }

            debugLog(
              `Loaded ${productType} ${
                isOBJ ? "OBJ" : "GLB"
              } model successfully.`,
              "success"
            );
            console.log(`${productType} loaded successfully!`);
            loadingIndicator.style.display = "none";

            // Automatically hide meshes defined in the product config
            const productConfigs = {
              poster: {
                hiddenMeshes: [],
              },
              tshirt: {
                hiddenMeshes: [],
              },
              mug: {
                hiddenMeshes: [],
              },
              cap: {
                hiddenMeshes: [],
              },
            };

            const config = productConfigs[productType];
            if (
              config &&
              config.hiddenMeshes &&
              Array.isArray(config.hiddenMeshes)
            ) {
              config.hiddenMeshes.forEach((meshName) => {
                currentModel.traverse((child) => {
                  if (child.isMesh && child.name === meshName) {
                    child.visible = false;
                    // Store original visibility state for potential restoration
                    child.userData.originalVisibility = child.visible;
                    console.log(`Automatically hidden mesh: ${meshName}`);
                    debugLog(`Automatically hidden mesh: ${meshName}`, "info");
                  }
                });
              });
            }

            // Force hide specific meshes for poster regardless of model default state
            if (productType === "poster") {
              const posterHiddenMeshes = ["Cube004"];
              const posterVisibleMeshes = ["Plane007", "plane006", "Plane006"];

              // Hide specified meshes
              posterHiddenMeshes.forEach((meshName) => {
                currentModel.traverse((child) => {
                  if (child.isMesh && child.name === meshName) {
                    child.visible = false;
                    child.userData.forceHidden = true;
                    console.log(`Force hidden poster mesh: ${meshName}`);
                    debugLog(`Force hidden poster mesh: ${meshName}`, "info");
                  }
                });
              });

              // Ensure specified meshes are visible
              posterVisibleMeshes.forEach((meshName) => {
                currentModel.traverse((child) => {
                  if (child.isMesh && child.name === meshName) {
                    child.visible = true;
                    child.userData.forceVisible = true;
                    console.log(`Force visible poster mesh: ${meshName}`);
                    debugLog(`Force visible poster mesh: ${meshName}`, "info");
                  }
                });
              });
            }
          },
          (progress) => {
            const percent = ((progress.loaded / progress.total) * 100).toFixed(
              1
            );
            loadingText.textContent = `Loading ${productType}... ${percent}%`;
            debugLog(`Loading ${productType}: ${percent}%`, "loading");
          },
          (error) => {
            debugLog(
              `Error loading ${productType} ${
                isOBJ ? "OBJ" : "GLB"
              } model: ${error}`,
              "error"
            );
            loadingIndicator.style.display = "none";
            // Show error message to user
            loadingText.textContent = `Error loading ${productType}. Please try again.`;
          }
        );
      }

      // --- Background Removal Integration ---
      let session = null; // ONNX Runtime session
      let modelLoaded = false;

      // Function to load the ONNX model and initialize the session
      async function loadBackgroundRemovalModel() {
        if (!ort) {
          notifications.show("ONNX Runtime not loaded.", "error");
          return;
        }
        try {
          // Load the model from a local path
          const modelPath = "./modnet_webcam_human_seg.onnx";
          const response = await fetch(modelPath);
          const buffer = await response.arrayBuffer();
          session = await ort.InferenceSession.create(buffer);
          modelLoaded = true;
          console.log("ONNX Model loaded successfully.");
        } catch (error) {
          console.error("Error loading ONNX model:", error);
          notifications.show("Failed to load background removal model.", "error");
        }
      }

      // Function to process an image with the ONNX model
      async function removeBackground(imageElement) {
        if (!modelLoaded || !session) {
          notifications.show(
            "Background removal model is not ready.",
            "warning"
          );
          return;
        }

        // Get the image data and prepare input tensor
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = imageElement.naturalWidth || imageElement.width;
        canvas.height = imageElement.naturalHeight || imageElement.height;
        ctx.drawImage(imageElement, 0, 0);

        const imageData = ctx.getImageData(
          0,
          0,
          canvas.width,
          canvas.height
        );

        // ONNX Model expects input shape: [batch_size, channels, height, width]
        // Assuming model input is Float32, normalized to [0, 1]
        const inputTensor = new ort.Tensor("float32", new Float32Array(canvas.width * canvas.height * 3), [1, 3, canvas.height, canvas.width]);

        const pixels = imageData.data;
        let i = 0;
        for (let y = 0; y < canvas.height; y++) {
          for (let x = 0; x < canvas.width; x++) {
            // Pixels are RGBA
            const r = pixels[(y * canvas.width + x) * 4] / 255.0;
            const g = pixels[(y * canvas.width + x) * 4 + 1] / 255.0;
            const b = pixels[(y * canvas.width + x) * 4 + 2] / 255.0;

            // Assuming model expects RGB input
            inputTensor.data[i++] = r;
            inputTensor.data[i++] = g;
            inputTensor.data[i++] = b;
          }
        }

        // Show background removal loading indicator
        const loadingIndicatorImage = document.getElementById(
          "loading-indicator-image"
        );
        loadingIndicatorImage.style.display = "block";

        // Run inference
        try {
          const outputMap = await session.run({ "input": inputTensor });
          const outputTensor = outputMap["output"]; // Assuming output name is "output"

          // Process the output to create a mask
          // The output is typically a map where higher values indicate foreground
          // The exact shape and interpretation depend on the ONNX model
          // For modnet, it's often a single channel mask
          const outputData = outputTensor.data;
          const mask = new Uint8ClampedArray(canvas.width * canvas.height * 4); // RGBA

          let k = 0;
          for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
              // Assuming output is a single channel, map it to alpha
              // Output values might need scaling or thresholding depending on the model
              // For modnet, values close to 1 are foreground
              const alphaValue = outputData[k++] * 255; // Scale to 0-255 for alpha

              // Set RGBA values
              mask[ (y * canvas.width + x) * 4 ] = pixels[(y * canvas.width + x) * 4];     // R
              mask[ (y * canvas.width + x) * 4 + 1 ] = pixels[(y * canvas.width + x) * 4 + 1]; // G
              mask[ (y * canvas.width + x) * 4 + 2 ] = pixels[(y * canvas.width + x) * 4 + 2]; // B
              mask[ (y * canvas.width + x) * 4 + 3 ] = alphaValue; // Alpha channel for transparency
            }
          }

          // Apply the mask to the image
          const maskedImageData = new ImageData(mask, canvas.width, canvas.height);
          ctx.putImageData(maskedImageData, 0, 0);

          // Update the uploadedImage variable with the masked image URL
          uploadedImage = canvas.toDataURL("image/png");
          applyTexture(uploadedImage); // Apply the masked image as texture
          console.log("Background removed and applied.");
          notifications.show("Background removed successfully!", "success");
        } catch (error) {
          console.error("Error during ONNX inference or processing:", error);
          notifications.show("Background removal failed.", "error");
        } finally {
          // Hide background removal loading indicator
          loadingIndicatorImage.style.display = "none";
        }
      }

      // Event listener for the "Remove Bg" button
      const removeBgButton = document.querySelector(".remove-bg-btn");
      removeBgButton.addEventListener("click", async () => {
        // This button is now handled by the controller.jsx file
        // The functionality has been moved there to work with the image layers system
        console.log("Remove background button clicked - handled by controller.jsx");
      });

      // Apply texture function
      function applyTexture(imageUrl) {
        // Since we're using an iframe for 3D, send message to the 3D canvas
        const message = {
          type: "apply-texture",
          payload: { url: imageUrl }
        };
        
        const canvas = document.getElementById("canvas");
        if (canvas && canvas.contentWindow) {
          canvas.contentWindow.postMessage(message, "https://damn-3dproduct-mpb8.vercel.app");
          console.log("Texture message sent to 3D canvas:", imageUrl);
        } else {
          console.warn("No 3D canvas found or no contentWindow available");
        }
      }

      // Event listener for image upload
      const imageUploadInput = document.getElementById("image-upload");
      const uploadArea = document.getElementById("upload-area");
      const imagePreview = document.createElement("img");
      imagePreview.id = "image-preview";
      imagePreview.style.cssText = `
          max-width: 100%;
          max-height: 200px;
          margin-top: 10px;
          border-radius: 8px;
          display: none !important;
          visibility: hidden;
          cursor: pointer;
      `;
      uploadArea.parentNode.insertBefore(imagePreview, uploadArea.nextSibling);

      // Image upload is now handled entirely by controller.jsx to avoid duplicate file dialogs

      // --- ONNX Runtime Loading ---
      // Dynamically load ONNX Runtime script
      const script = document.createElement("script");
      script.src = "https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.js";
      script.onload = () => {
        console.log("ONNX Runtime loaded.");
        // Optionally load the model here or wait for button click
        // loadBackgroundRemovalModel();
      };
      script.onerror = () => {
        console.error("Failed to load ONNX Runtime.");
        notifications.show("ONNX Runtime failed to load.", "error");
      };
      document.head.appendChild(script);

      // --- End Background Removal Integration ---

      // Toggle between Image and Text customization
      document.querySelectorAll(".customization-buttons button").forEach((button) => {
        button.addEventListener("click", () => {
          document
            .querySelectorAll(".customization-buttons button")
            .forEach((btn) => btn.classList.remove("active"));
          button.classList.add("active");

          const targetId = button.textContent.toLowerCase() + "-customization";
          document.querySelectorAll(".configurator-controls > div").forEach((div) => {
            div.style.display = div.id === targetId ? "block" : "none";
          });
        });
      });

      // Auto rotate functionality
      let autoRotate = false; // Initially false, will toggle
      document.getElementById("auto-rotate-btn").addEventListener("click", () => {
        autoRotate = !autoRotate;
        const button = document.getElementById("auto-rotate-btn");
        if (autoRotate) {
          button.textContent = "Stop Rotate";
          button.classList.add("active");
        } else {
          button.textContent = "Start Rotate";
          button.classList.remove("active");
        }
      });

      // --- Export Functionality ---
      document.getElementById("export-view-btn").addEventListener("click", () => {
        if (!renderer || !scene || !camera) {
          notifications.show("3D scene not initialized.", "error");
          return;
        }

        // Render the current view to a canvas
        const exportCanvas = document.createElement("canvas");
        exportCanvas.width = renderer.domElement.width;
        exportCanvas.height = renderer.domElement.height;
        const exportCtx = exportCanvas.getContext("2d");
        exportCtx.drawImage(renderer.domElement, 0, 0);

        // Convert canvas to data URL and trigger download
        const dataURL = exportCanvas.toDataURL("image/png");
        const link = document.createElement("a");
        link.href = dataURL;
        link.download = `${currentProduct}_customized.png`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        notifications.show("Export successful!", "success");
      });

      // Global variables for THREE.js objects, ensure they are declared globally if used outside functions
      let scene, camera, renderer, controls;

      // Initialize application when the DOM is fully loaded
      document.addEventListener("DOMContentLoaded", () => {
        initializeApplication();
      });

      // Function to initialize the application, including the 3D scene
      function initializeApplication() {
        // Initialize 3D scene
        init3DScene();

        // Show welcome message
        console.log("3D Configurator initialized successfully!");

        // Listen for messages from the controller
        window.addEventListener("message", (event) => {
          const { type, payload } = event.data;
          
          if (type === "replace-image-texture" && payload) {
            console.log("Received texture replacement message:", payload);
            if (payload.url) {
              // Apply the background-removed image to the 3D model
              applyTexture(payload.url);
              // Store the updated image
              uploadedImage = payload.url;
            }
          } else if (type === "update-image-texture" && payload) {
            console.log("Received texture update message:", payload);
            if (payload.url) {
              // Apply the background-removed image to the 3D model
              applyTexture(payload.url);
              // Store the updated image
              uploadedImage = payload.url;
              
              // Show the updated image in preview
              const preview = document.getElementById("image-preview");
              if (preview) {
                preview.src = payload.url;
                preview.style.display = "block";
              }
            }
          }
        });
      }

      // Debounced texture update function
      const debouncedUpdateTexture = debounce((type, value) => {
        if (!targetMaterial) return;
        
        // Since we're using an iframe for 3D, send message to the 3D canvas
        const message = {
          type: "update-texture-property",
          payload: { type, value }
        };
        
        const canvas = document.getElementById("canvas");
        if (canvas && canvas.contentWindow) {
          canvas.contentWindow.postMessage(message, "*");
        }
      }, 100);

      // Function to update numeric value displays
      function updateValueDisplays() {
        const sizeSlider = document.querySelector("#image-customization #size-slider");
        const xPositionSlider = document.querySelector("#image-customization #x-position");
        const yPositionSlider = document.querySelector("#image-customization #y-position");
        
        const sizeDisplay = document.getElementById("size-value-display");
        const xPositionDisplay = document.getElementById("x-position-value-display");
        const yPositionDisplay = document.getElementById("y-position-value-display");
        
        if (sizeSlider && sizeDisplay) {
          sizeDisplay.textContent = sizeSlider.value;
        }
        if (xPositionSlider && xPositionDisplay) {
          xPositionDisplay.textContent = parseFloat(xPositionSlider.value).toFixed(1);
        }
        if (yPositionSlider && yPositionDisplay) {
          yPositionDisplay.textContent = parseFloat(yPositionSlider.value).toFixed(1);
        }
      }

      // Add event listeners to update displays when sliders change
      document.addEventListener("DOMContentLoaded", () => {
        const sizeSlider = document.querySelector("#image-customization #size-slider");
        const xPositionSlider = document.querySelector("#image-customization #x-position");
        const yPositionSlider = document.querySelector("#image-customization #y-position");
        
        if (sizeSlider) {
          sizeSlider.addEventListener("input", updateValueDisplays);
        }
        if (xPositionSlider) {
          xPositionSlider.addEventListener("input", updateValueDisplays);
        }
        if (yPositionSlider) {
          yPositionSlider.addEventListener("input", updateValueDisplays);
        }
        
        // Initial update
        updateValueDisplays();
      });
      // Product selection
      document.querySelectorAll(".product-item").forEach((item) => {
        item.addEventListener("click", () => {
          document
            .querySelectorAll(".product-item")
            .forEach((p) => p.classList.remove("featured"));
          item.classList.add("featured");

          const price = item.querySelector(".product-price").textContent;
          document.querySelector(".preview-price").textContent = price;

          const productType = item.dataset.product;
          loadProductModel(productType);
        });
      });
      // Function to update texture from URL
      function updateTextureFromUrl(imageUrl) {
        if (!targetMaterial) {
          console.warn("No target material available for texture update");
          return;
        }

        const textureLoader = new THREE.TextureLoader();
        textureLoader.load(
          imageUrl,
          (texture) => {
            // Dispose of old texture to prevent memory leaks
            if (targetMaterial.map) {
              targetMaterial.map.dispose();
            }

            // Apply new texture
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.flipY = false;
            
            targetMaterial.map = texture;
            targetMaterial.needsUpdate = true;
            
            console.log("Texture updated successfully from background removal");
          },
          undefined,
          (error) => {
            console.error("Error loading updated texture:", error);
            notifications.show("Error applying background removed image.", "error");
          }
        );
      }

      // Enhanced reset function
      function resetAll() {
        if (targetMaterial && targetMaterial.map) {
          targetMaterial.map = null;
          targetMaterial.needsUpdate = true;
        }

        // Reset all controls
        document.getElementById("size-slider").value = 1;
        document.getElementById("x-position").value = 0;
        document.getElementById("y-position").value = 0;
        document.getElementById("rotation-slider").value = 0;

        // Clear uploaded image and reset preview
        uploadedImage = null;
        const imagePreview = document.getElementById("image-preview");
        if (imagePreview) {
          imagePreview.src = "";
          imagePreview.style.display = "none";
        }

        // Reset materials to default color
        if (currentModel) {
          currentModel.traverse((child) => {
            if (child.isMesh && child.material) {
              const materials = Array.isArray(child.material)
                ? child.material
                : [child.material];
              materials.forEach((mat) => {
                const originalMatKey = `${child.name}_${mat.uuid}`; // Use uuid for array materials
                const originalMat = originalMaterials.get(originalMatKey) || originalMaterials.get(child); // Fallback to direct mesh key

                if (originalMat) {
                  mat.copy(originalMat); // Restore original material properties
                  mat.needsUpdate = true;
                } else {
                  // If no original material found, reset to a default white
                  mat.color.setHex(0xffffff);
                  mat.needsUpdate = true;
                }
              });
            }
          });
        }

        // Ensure poster meshes maintain their desired state after reset
        if (currentProduct === "poster" && currentModel) {
          const posterHiddenMeshes = ["Cube004"];
          const posterVisibleMeshes = ["Plane007", "plane006", "Plane006"];

          // Keep specified meshes hidden
          posterHiddenMeshes.forEach((meshName) => {
            currentModel.traverse((child) => {
              if (child.isMesh && child.name === meshName) {
                child.visible = false;
              }
            });
          });

          // Keep specified meshes visible
          posterVisibleMeshes.forEach((meshName) => {
            currentModel.traverse((child) => {
              if (child.isMesh && child.name === meshName) {
                child.visible = true;
              }
            });
          });
        }

        console.log("Reset complete!");
        notifications.show("Reset complete!", "success");
      }
    </script>
    <script src="./controller.jsx"></script>

    <deepl-input-controller translate="no"
      ><template shadowrootmode="open"
        ><link
          rel="stylesheet"
          href="chrome-extension://cofdbpoegempjloogbagkncekinflcnj/build/content.css" />
        <div dir="ltr" style="visibility: initial !important">
          <div class="dl-input-translation-container svelte-95aucy">
            <div></div>
          </div></div></template
    ></deepl-input-controller>
  </body>
</html>
